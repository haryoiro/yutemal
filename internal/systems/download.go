package systems

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/haryoiro/yutemal/internal/constants"
	"github.com/haryoiro/yutemal/internal/database"
	"github.com/haryoiro/yutemal/internal/logger"
	"github.com/haryoiro/yutemal/internal/structures"
)

// DownloadSystem manages music downloads
type DownloadSystem struct {
	config         *structures.Config
	database       database.DB
	cacheDir       string
	downloadDir    string
	cookiesFile    string // Path to cookies file for yt-dlp
	queue          chan structures.Track
	workers        int
	wg             sync.WaitGroup
	ctx            context.Context
	cancel         context.CancelFunc
	inProgress     sync.Map // trackID -> bool
	statusCallback func(trackID string, status structures.MusicDownloadStatus)
}

// NewDownloadSystem creates a new download system
func NewDownloadSystem(cfg *structures.Config, db database.DB, cacheDir string) *DownloadSystem {
	ctx, cancel := context.WithCancel(context.Background())

	downloadDir := filepath.Join(cacheDir, "downloads")
	os.MkdirAll(downloadDir, 0755)

	return &DownloadSystem{
		config:      cfg,
		database:    db,
		cacheDir:    cacheDir,
		downloadDir: downloadDir,
		queue:       make(chan structures.Track, constants.DefaultQueueSize),
		workers:     cfg.MaxConcurrentDownloads,
		ctx:         ctx,
		cancel:      cancel,
	}
}

// Start starts the download workers
func (ds *DownloadSystem) Start() error {
	for i := 0; i < ds.workers; i++ {
		ds.wg.Add(1)
		go ds.worker(i)
	}
	return nil
}

// Stop stops all download workers
func (ds *DownloadSystem) Stop() {
	// Cancel context first to signal workers to stop
	ds.cancel()
	// Wait for all workers to finish
	ds.wg.Wait()
	// Close queue after workers have finished
	close(ds.queue)
}

// SetStatusCallback sets the callback for download status updates
func (ds *DownloadSystem) SetStatusCallback(callback func(trackID string, status structures.MusicDownloadStatus)) {
	ds.statusCallback = callback
}

// SetHeaderFile sets the header file for authentication and creates cookies file
func (ds *DownloadSystem) SetHeaderFile(headerPath string) error {
	// Read header file
	content, err := os.ReadFile(headerPath)
	if err != nil {
		return fmt.Errorf("failed to read header file: %w", err)
	}

	// Parse headers to extract cookies
	lines := strings.Split(string(content), "\n")
	var cookieHeader string
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "Cookie:") || strings.HasPrefix(line, "cookie:") {
			cookieHeader = strings.TrimSpace(line[7:]) // Remove "Cookie: " prefix
			break
		}
	}

	if cookieHeader == "" {
		return fmt.Errorf("no Cookie header found in file")
	}

	// Create cookies file in Netscape format for yt-dlp
	cookiesPath := filepath.Join(ds.cacheDir, "cookies.txt")
	cookiesFile, err := os.Create(cookiesPath)
	if err != nil {
		return fmt.Errorf("failed to create cookies file: %w", err)
	}
	defer cookiesFile.Close()

	// Write cookie format header
	fmt.Fprintln(cookiesFile, "# HTTP Cookie File")
	fmt.Fprintln(cookiesFile, "# This file was generated by yutemal")

	// Parse and convert cookies
	cookies := strings.Split(cookieHeader, ";")
	for _, cookie := range cookies {
		cookie = strings.TrimSpace(cookie)
		if cookie == "" {
			continue
		}

		parts := strings.SplitN(cookie, "=", 2)
		if len(parts) != 2 {
			continue
		}

		name := strings.TrimSpace(parts[0])
		value := strings.TrimSpace(parts[1])

		// Write cookie in Netscape format
		// Format: domain flag path secure expiration name value
		fmt.Fprintf(cookiesFile, ".youtube.com\tTRUE\t/\tTRUE\t0\t%s\t%s\n", name, value)
	}

	ds.cookiesFile = cookiesPath
	logger.Info("Created cookies file at: %s", cookiesPath)
	return nil
}

// QueueDownload adds a track to the download queue
func (ds *DownloadSystem) QueueDownload(track structures.Track) {
	// Check if already downloading
	if _, exists := ds.inProgress.Load(track.TrackID); exists {
		return
	}

	// Check if already downloaded
	if _, exists := ds.database.Get(track.TrackID); exists {
		return
	}

	// Mark as in progress
	ds.inProgress.Store(track.TrackID, true)

	select {
	case ds.queue <- track:
	default:
		// Queue full
		ds.inProgress.Delete(track.TrackID)
	}
}

// worker is a download worker goroutine
func (ds *DownloadSystem) worker(id int) {
	defer ds.wg.Done()

	for {
		select {
		case track, ok := <-ds.queue:
			if !ok {
				return
			}

			// Emit downloading status
			ds.emitStatus(track.TrackID, structures.Downloading)

			if err := ds.downloadTrack(track); err != nil {
				logger.Error("Worker %d: Failed to download %s (%s - %s): %v", id, track.TrackID, track.Title, track.Artists, err)
				// Emit failed status
				ds.emitStatus(track.TrackID, structures.DownloadFailed)
			} else {
				logger.Info("Worker %d: Successfully downloaded %s (%s)", id, track.TrackID, track.Title)
				// Emit downloaded status
				ds.emitStatus(track.TrackID, structures.Downloaded)
			}

			// Remove from in-progress
			ds.inProgress.Delete(track.TrackID)

		case <-ds.ctx.Done():
			return
		}
	}
}

// downloadTrack downloads a single track using yt-dlp with retry mechanism
func (ds *DownloadSystem) downloadTrack(track structures.Track) error {
	outputPath := filepath.Join(ds.downloadDir, track.TrackID+".mp3")

	// Check if already downloaded
	if _, err := os.Stat(outputPath); err == nil {
		logger.Debug("track %s already downloaded", track.TrackID)
		return ds.updateDatabase(track, outputPath)
	}

	logger.Info("Starting download for track %s (%s by %s)", track.TrackID, track.Title, strings.Join(track.Artists, ", "))

	// Retry up to MaxDownloadRetries times
	maxRetries := constants.MaxDownloadRetries
	var lastErr error

	for retry := 0; retry < maxRetries; retry++ {
		if retry > 0 {
			logger.Warn("Retrying download for %s (attempt %d/%d)", track.TrackID, retry+1, maxRetries)
			// Wait before retry
			time.Sleep(constants.DownloadRetryDelay * time.Duration(retry))
		}

		// Build yt-dlp command with cookies if available
		args := []string{
			"--extract-audio",
			"--audio-format", "mp3",
			"--audio-quality", constants.AudioQuality, // Best quality
			"--no-playlist",
			"--no-check-certificates", // Add this to avoid SSL issues
			"--user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
			"--output", filepath.Join(ds.downloadDir, "%(id)s.%(ext)s"),
		}

		// Add cookies file if available
		if ds.cookiesFile != "" {
			args = append(args, "--cookies", ds.cookiesFile)
		}

		// Add verbose logging and URL
		args = append(args,
			"--verbose", // Add verbose logging
			"--",        // End of options
			fmt.Sprintf("https://www.youtube.com/watch?v=%s", track.TrackID),
		)

		cmd := exec.CommandContext(ds.ctx, "yt-dlp", args...)

		// Capture output for debugging
		output, err := cmd.CombinedOutput()
		if err != nil {
			lastErr = err
			logger.Error("yt-dlp failed for %s (attempt %d): %v\nOutput: %s", track.TrackID, retry+1, err, string(output))

			// Check if context was cancelled
			if ds.ctx.Err() != nil {
				return fmt.Errorf("download cancelled: %w", ds.ctx.Err())
			}

			continue
		}

		// Success
		logger.Info("Successfully downloaded %s", track.TrackID)

		// Update database
		return ds.updateDatabase(track, outputPath)
	}

	return fmt.Errorf("download failed after %d attempts: %w", maxRetries, lastErr)
}

// updateDatabase updates the database with download info
func (ds *DownloadSystem) updateDatabase(track structures.Track, filePath string) error {
	// Get file size
	fileInfo, err := os.Stat(filePath)
	if err != nil {
		return fmt.Errorf("failed to stat file: %w", err)
	}

	// Create database entry
	entry := structures.DatabaseEntry{
		Track:    track,
		FilePath: filePath,
		AddedAt:  time.Now(),
		FileSize: fileInfo.Size(),
	}

	// Add to database
	if err := ds.database.Add(entry); err != nil {
		return fmt.Errorf("failed to update database: %w", err)
	}

	return nil
}

// IsDownloading checks if a track is currently downloading
func (ds *DownloadSystem) IsDownloading(trackID string) bool {
	_, exists := ds.inProgress.Load(trackID)
	return exists
}

// emitStatus emits a status update if a callback is set
func (ds *DownloadSystem) emitStatus(trackID string, status structures.MusicDownloadStatus) {
	if ds.statusCallback != nil {
		ds.statusCallback(trackID, status)
	}
}

// CleanupOldFiles removes downloaded files that haven't been accessed in the specified duration
func (ds *DownloadSystem) CleanupOldFiles(maxAge time.Duration) error {
	entries, err := os.ReadDir(ds.downloadDir)
	if err != nil {
		return fmt.Errorf("failed to read download directory: %w", err)
	}

	now := time.Now()
	var totalSize int64
	var removedCount int

	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}

		filePath := filepath.Join(ds.downloadDir, entry.Name())
		info, err := entry.Info()
		if err != nil {
			logger.Error("Failed to get info for %s: %v", filePath, err)
			continue
		}

		// Check if file is old enough
		if now.Sub(info.ModTime()) > maxAge {
			// Extract track ID from filename (format: trackID.mp3)
			trackID := strings.TrimSuffix(entry.Name(), filepath.Ext(entry.Name()))

			// Check if it's in the database
			if _, exists := ds.database.Get(trackID); exists {
				// Remove from database
				if err := ds.database.Remove(trackID); err != nil {
					logger.Error("Failed to remove %s from database: %v", trackID, err)
					continue
				}
			}

			// Remove file
			if err := os.Remove(filePath); err != nil {
				logger.Error("Failed to remove file %s: %v", filePath, err)
				continue
			}

			totalSize += info.Size()
			removedCount++
			logger.Debug("Removed old file: %s", filePath)
		}
	}

	logger.Info("Cleanup complete: removed %d files, freed %d MB", removedCount, totalSize/(1024*1024))
	return nil
}

// GetCacheSize returns the total size of cached downloads in bytes
func (ds *DownloadSystem) GetCacheSize() (int64, error) {
	entries, err := os.ReadDir(ds.downloadDir)
	if err != nil {
		return 0, fmt.Errorf("failed to read download directory: %w", err)
	}

	var totalSize int64
	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}

		info, err := entry.Info()
		if err != nil {
			continue
		}

		totalSize += info.Size()
	}

	return totalSize, nil
}
